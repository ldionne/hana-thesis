\section{Les foncteurs}
Nous avons introduit la notion de catégorie à l'aide d'exemples provenant de
l'algèbre abstraite, de l'analyse puis de l'informatique. L'algorithme pour
\textit{catégoriser} une théorie était toujours un peu le même: isoler les
objets d'étude de la théorie, isoler les propriétés importantes qui les
définissent puis considérer l'ensemble des transformations qui, de manière
informelle, respectent ces propriétés. Or, la théorie des catégorie est
elle-même une théorie qui étudie certains objets appelés ``catégories''.
Il serait donc naturel de se demander s'il est possible de définir des
transformations entre les catégories et, si c'est le cas, quelles propriétés
doivent posséder ces transformations pour qu'on obtienne quelque chose
d'intéressant. Comme on s'apprête à le voir, ce questionnement et sa
réponse sont à la source de la notion de \textit{foncteur}, qui n'est
en effet rien d'autre qu'une transformation entre catégories.

D'abord, une catégorie $\C$ possède non seulement des objets, mais aussi
des flèches entre ces objets. Ainsi, peu importe la forme que prendra notre
transformation inter-catégories, elle devra spécifier où elle envoie les
objets, mais aussi les flèches. Considérons donc une application $F : \C \to \D$
d'une catégorie $\C$ vers une catégorie $\D$. On devra avoir que pour chaque
objet $A \in \ob(\C)$, $F$ envoie $A$ vers un objet de $\D$, disons
$F(A) \in \ob(\D)$. De manière similaire, pour chaque flèche
$f : A \to B \in \hom(\C)$, $F$ devra envoyer $f$ sur une flèche
de $\D$, disons $F(f) \in \hom(\D)$.

Il est intéressant de remarquer que l'on a pas spécifié la source ni la
destination de la flèche $F(f)$. En fait, pour une flèche $f : A \to B$,
seuls deux choix s'offrent à nous: soit $F(f) : F(A) \to F(B)$, soit
$F(f) : F(B) \to F(A)$. Ces deux choix sont valables. Dans le premier cas,
on dira que c'est un foncteur \textit{covariant}, ou juste un foncteur, et
dans l'autre cas on dira que c'est un foncteur \textit{contravariant}. Dans
le cadre actuel, nous nous intéresserons seulement aux foncteurs covariants.

Ensuite, une catégorie possède une loi de composition et chaque objet doit
posséder une flèche identité; il serait probablement intéressant qu'une
transformation entre catégories préserve ces propriétés d'une certaine manière.
On demandera donc que la loi de composition soit respectée, c'est-à-dire que
pour des flèches $f : A \to B$ et $g : B \to C$ de $\C$,
\[
    F(g \circ_\C f) = F(g) \circ_\D F(f)
\]

Il est possible de visualiser cette équation sous la forme d'un diagramme.
En effet, dire que cette équation est satisfaite est équivalent à dire que
le diagramme suivant commute:
\[
\begin{tikzcd}
    A \arrow[r, red, "f" black] \arrow[d, blue, "F" black] & B \arrow[r, red, "g" black] & C \arrow[d, red, "F" black] \\
    F(A) \arrow[r, blue, "F(f)" black] & F(B) \arrow[r, blue, "F(g)" black] & F(C)
\end{tikzcd}
\]

En d'autres mots, on souhaite que les chemins bleus et rouges donnent
exactement la même réponse. Ensuite, au même titre qu'on souhaite que la loi
de composition soit respectée, on demandera que les flèches identité soient
préservées par un foncteur, c'est-à-dire que pour un objet $A$ de $\C$,
\[
    F(id_A) = id_{F(A)}
\]

Ceci nous mène à la définition formelle suivante:

\begin{définition}[Foncteur]
    Un foncteur $F : \C \to \D$ d'une catégorie $\C$ vers une catégorie $\D$
    est une application qui
    \begin{enumerate}
        \item à chaque objet $X \in \ob(\C)$ associe un objet $F(X) \in \ob(\D)$
        \item à chaque flèche $f : A \to B \in \hom(\C)$ associe une flèche
              $F(f) : F(A) \to F(B) \in \hom(\D)$
        \item respecte la loi de composition, c'est-à-dire que pour toutes
              flèches $f : A \to B$ et $g : B \to C \in \hom(\C)$,
              $F(g \circ_\C f) = F(g) \circ_\D F(f)$
        \item préserve les identités, c'est-à-dire que pour tout objet
              $X \in \ob(\C)$, $F(\id_X) = \id_{F(X)}$
    \end{enumerate}
\end{définition}

Lorsque le domaine et le codomaine d'un foncteur sont la même catégorie, i.e.
lorsqu'on a un foncteur du type $F : \C \to \C$, on dira parfois que $F$ est
un \textit{endofoncteur}.


\subsection{Les foncteurs dans Hana}
Dans le cadre de la bibliothèque Hana, on s'intéressera principalement aux
endofoncteurs sur la catégorie Hana, c'est-à-dire aux foncteurs du type
$F : Hana \to Hana$. D'abord, rappelons-nous que les objets de la catégorie
Hana sont des types généralisés. Un foncteur $F$ devra donc envoyer un type
généralisé $T$ vers un autre type généralisé $F(T)$. Ensuite, les flèches de
Hana sont des fonctions dont le domaine et le codomaine sont des types
généralisés. Ainsi, un foncteur $F$ devra envoyer une telle fonction
$f : T \to U$ vers une fonction $F(f) : F(T) \to F(U)$. Dans Hana, un
foncteur se matérialise comme un type généralisé paramétré et muni d'une
fonction appelée \icpp{transform} ayant la pseudo-signature suivante:
\[
    \icpp{transform} : F(T) \times (T \to U) \to F(U)
\]

Si un type généralisé paramétré $F$ est un foncteur au sens de Hana, alors
$F(T)$ est le type généralisé correspondant à l'image de $T$ par le foncteur
$F$. Cependant, le rôle de \icpp{transform} demande un peu plus de
justification. On notera que l'ordre des paramètres de \icpp{transform} est
fâcheux pour l'explication qui suit. C'est tout de même cet ordre qui est
utilisé dans Hana parce qu'il est avantageux lorsqu'on veut passer une
fonction anonyme C++ à \icpp{transform}. Supposons que l'on ait une fonction
$f : T \to U$. On peut appliquer partiellement $f$ à \icpp{transform} pour
obtenir la fonction
\[
    \icpp{transform(-, f)} : F(T) \to F(U)
\]

On peut remarquer que \icpp{transform(-, f)} possède la signature requise
pour être l'image d'une flèche de Hana par le foncteur $F$. Dans la catégorie
Hana, un foncteur $F$ envoie donc un type généralisé $T$ sur un nouveau type
généralisé $U$, et une fonction $f : T \to U$ sur une nouvelle fonction
$\icpp{transform(-, f)} : F(T) \to F(U)$. Bien entendu, pour qu'il s'agisse
bien d'un foncteur, certaines propriétés doivent être respectées. D'abord,
le foncteur doit respecter la loi de composition de Hana, i.e. pour toutes
fonctions $f : A \to B$ et $g : B \to C$, on doit avoir que
$F(g \circ f) = F(g) \circ F(f)$.

Dans Hana, ceci devient simplement
\[
    \icpp{transform(-, g} \circ \icpp{f)} = \icpp{transform(-, g)} \circ \icpp{transform(-, f)},
\]

ce qui est équivalent à dire que pour tout \icpp{xs} de type généralisé $F(T)$,
\[
    \icpp{transform(xs, g} \circ \icpp{f)} = \icpp{transform(transform(xs, f), g)}
\]

Ensuite, le foncteur doit aussi respecter l'identité, c'est à dire que
$F(\id_T) = \id_{F(T)}$. Dans Hana, puisque l'identité est une fonction
générique qui fonctionne sur tous les types généralisés, ceci se traduit
simplement par
\[
    \icpp{transform(-, id)} = \icpp{id},
\]

ce qui est équivalent à dire que pour tout \icpp{xs} de type généralisé $F(T)$,
\[
    \icpp{transform(xs, id)} = \icpp{xs}
\]

Voyons maintenant comment certaines structures fournies par Hana peuvent
être vues comme des foncteurs.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Le foncteur Maybe}
En programmation, on est souvent amené à utiliser des fonctions qui peuvent
échouer. Par exemple, lorsqu'on divise une quantité par une autre, il peut
arriver que le dénominateur soit nul, auquel cas la division ne peut avoir
lieu. Un autre exemple serait une fonction qui accède au n-ième élément
d'une séquence; il peut arriver que la séquence contienne moins de $n$
éléments, auquel cas la fonction ne peut pas retourner de résultat. Or,
en programmation, il nous faut une manière de gérer ces éventualités. Un
mécanisme classique pour y arriver est d'utiliser des exceptions. Cependant,
un des désavantages des exceptions est qu'elles ne sont généralement pas
encodées dans le type de la fonction qui peut les produire, et le fardeau
de bien les gérer appartient donc au programmeur. Un autre problème majeur
dans le contexte de la métaprogrammation est que les exceptions n'existent
pas au moment de la compilation, et ce mécanisme nous est donc complètement
inaccessible.

Une autre manière de gérer la possibilité d'un échec est d'introduire la
notion de valeur optionnelle. Essentiellement, une valeur optionnelle est
une valeur qui peut être là ou ne pas y être, accompagnée d'un mécanisme
pour savoir si la valeur est là ou non. Pour une valeur de type \icpp{T},
on dénotera une valeur optionnelle de ce type par le type \icpp{Maybe(T)}.
Une valeur optionnelle peut être créée de deux manières. D'abord, on peut
créer une valeur optionnelle (qui existe) avec \icpp{just(x)}, où \icpp{x}
est une valeur de type \icpp{T}. Ensuite, on peut créer une valeur optionnelle
qui est vide avec \icpp{nothing}. Ainsi, alors qu'on pourrait écrire une
fonction qui effectue une division comme:
\begin{align*}
    div : \mathbb{R} \times \mathbb{R} &\to \mathbb{R} \\
           x, y &\mapsto x / y
\end{align*}

on pourrait aussi écrire une fonction qui effectue la division de manière
sécuritaire en utilisant \icpp{Maybe}:
\begin{align*}
    safe\_div : \mathbb{R} \times \mathbb{R} &\to Maybe(\mathbb{R}) \\
                 x, y &\mapsto  \begin{cases}
                                    nothing \text{ si y = 0} \\
                                    just(x / y) \text{ sinon}
                                \end{cases}
\end{align*}

Pour l'instant, ceci ne nous est pas très utile parce que nous n'avons pas
de façon d'extraire la valeur optionnelle lorsqu'elle existe. C'est le rôle
de la fonction \icpp{from_just}, qui est définie par
\begin{align*}
    from\_just : Maybe(T) &\to T \\
                 just(x) &\mapsto x \\
                 nothing &\mapsto erreur
\end{align*}

Pour que ceci nous soit d'une quelconque utilité, il nous faut aussi une
manière de savoir quand est-ce qu'une valeur optionnelle est vide ou pleine:
\begin{align*}
    is\_nothing : Maybe(T) &\to bool \\
                 just(x) &\mapsto false \\
                 nothing &\mapsto true
\end{align*}

On peut ensuite utiliser le résultat de \icpp{safe_div} comme suit:
\begin{cpp}
    auto maybe_result = safe_div(x, y);
    if (!is_nothing(maybe_result)) {
        auto result = from_just(maybe_result);
        ...
    }
\end{cpp}

On constate rapidement que le gain est plutôt faible par rapport à une
solution où on vérifierait explicitement que \icpp{y != 0} et où l'on
n'utiliserait pas de \icpp{Maybe}. En effet, il est quand même nécessaire
de vérifier si la valeur optionnelle est vide ou pleine avant de pouvoir
utiliser le résultat de la fonction (si résultat il y a). Ce qu'on aimerait
est une manière de seulement spécifier le contenu de la branche (par exemple
comme une fonction) et de soit appliquer la fonction au contenu du \icpp{Maybe},
soit ne pas l'appliquer et avoir \icpp{nothing}. Mathématiquement, si la
branche est représentée par une fonction
\begin{align*}
    f : A &\to B \\
        x &\mapsto f(x)
\end{align*}

on aimerait (automatiquement) être capable de produire une fonction
\begin{align*}
    g : Maybe(A) &\to Maybe(B) \\
        just(x) &\mapsto just(f(x)) \\
        nothing &\mapsto nothing
\end{align*}

De cette manière, on pourrait simplement écrire
\begin{cpp}
    auto maybe_result = safe_div(x, y);
    g(maybe_result);
\end{cpp}

Comme on pouvait s'en douter, nous venons de mettre le doigt sur un foncteur.
En effet, étant donné un objet $A$ de la catégorie $Hana$, le foncteur $Maybe$
envoie $A$ sur $Maybe(A)$. Ensuite, étant donné une flèche $f : A \to B$,
$Maybe$ envoie $f$ sur
\begin{align*}
    transform(-, f) : Maybe(A) &\to Maybe(B)        \\
                      just(x) &\mapsto just(f(x))   \\
                      nothing &\mapsto nothing
\end{align*}

Afin de démontrer la fonctorialité de \icpp{Maybe}, commençons par regarder
comment celui-ci est implémenté dans Hana. D'abord, on a \icpp{just} et
\icpp{nothing}, qui représentent des valeurs optionnelles.
\begin{cpp}
    template <typename T>
    struct _just { T value; };

    auto just = [](auto x) {
        return _just<decltype(x)>{x};
    };

    struct _nothing { };
    _nothing nothing{};
\end{cpp}

Ensuite, on a la fonction \icpp{transform}, qui applique une fonction à une
valeur optionnelle et qui retourne un résultat optionnel. On notera
l'utilisation de l'\textit{overloading} dans l'implémentation:
\begin{cpp}
    template <typename T, typename F>
    auto transform(_just<T> x, F f) {
        return just(f(x.value));
    }

    template <typename F>
    auto transform(_nothing, F) {
        return nothing;
    }
\end{cpp}

Si un \icpp{just(x)} est passé à \icpp{transform}, on applique la fonction
\icpp{f} à \icpp{x} et on retourne le résultat comme un \icpp{Maybe}. Sinon,
on retourne simplement \icpp{nothing}, puisqu'il n'y a pas de valeur à
laquelle on pourrait appliquer \icpp{f}. Montrons maintenant que \icpp{Maybe}
est un endofoncteur sur $Hana$. D'abord, on doit montrer que \icpp{transform}er
une valeur optionnelle avec la fonction identité ne change pas cette valeur
optionnelle. Soit donc $x \in Maybe(A)$ une valeur optionnelle de type $A$.
Si $x$ est de la forme $just(v)$, alors
\begin{cpp}
    transform(x, id) == transform(just(v), id)
                     == just(id(v))
                     == just(v)
                     == x
\end{cpp}

Si, au contraire, $x$ est un $nothing$, alors
\begin{cpp}
    transform(x, id) == transform(nothing, id)
                     == nothing
\end{cpp}

ce qui montre que \icpp{transform(-, id) == id}. Ensuite, il faut montrer
que la composition des fonctions est respectée par \icpp{transform}. Soit
$x \in Maybe(A)$ une valeur optionnelle et $f : A \to B$ et $g : B \to C$
des fonctions quelconques. Si $x$ est de la forme $just(v)$, alors
\begin{cpp}
    transform(x, compose(g, f)) == transform(just(v), compose(g, f))
                                == just(compose(g, f)(v))
                                == just(g(f(v)))
\end{cpp}

d'un autre côté, on a que
\begin{cpp}
    transform(transform(x, f), g) == transform(transform(just(v), f), g)
                                  == transform(just(f(v)), g)
                                  == just(g(f(v)))
\end{cpp}

ce qui montre l'égalité recherchée. Ainsi, $Maybe$ est bien un foncteur
sur la catégorie $Hana$.

\todo{Exemples d'utilisation. Pourquoi est-ce utile?
Ça serait possible de mixer ça avec des calculs sur les types et la SFINAE.}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Le foncteur Tuple}
Jusqu'ici, nous avons vu comment faire des calculs arithmétiques et des
transformations sur des types au moment de la compilation. Nous avons aussi
vu comment il est possible de représenter une valeur optionnelle à l'aide d'un
foncteur, ce qui est particulièrement utile pour représenter le résultat
d'une fonction qui peut échouer. Nous allons maintenant voir comment il est
possible de manipuler des séquences d'objets, et comment la notion de foncteur
peut nous aider à formaliser ceci.

Étant donné une séquence d'objets $x_1, \hdots, x_n$ de type $X$ et une
fonction $f : X \to Y$, il est fréquemment utile d'appliquer $f$ à chaque
élément de la séquence pour obtenir une nouvelle séquence $f(x_1), \hdots, f(x_n)$.
On aimerait donc formaliser ce \textit{pattern} puis le généraliser, si possible.
Premièrement, il nous faut une séquence capable de contenir des objets d'un
type généralisé $X$ quelconque. On notera que puisque des objets d'un même type
généralisé n'ont pas forcément le même type C++, on ne peut pas utiliser une
séquence conventionnelle comme \icpp{std::vector}. On devra en effet utiliser
une séquence hétérogène capable de contenir des objets ayant différents types
C++. La véritable construction dans Hana est assez complexe pour des raisons
techniques, mais l'idée est essentiellement la suivante:
\begin{cpp}
    template <int i, typename T>
    struct _element { T value; };

    template <typename T1, ..., typename Tn>
    struct _tuple : _element<0, T1>, ..., _element<n-1, Tn> {
        // ... constructeur omis pour la simplicité
    };

    template <typename ...T>
    _tuple<T...> make_tuple(T ...t) {
        return {t...};
    }
\end{cpp}

On utilise le type \icpp{_element<i, T>} pour stocker l'objet de type \icpp{T}
situé à l'index \icpp{i} dans la séquence. On se donne aussi un peu de sucre
syntaxique (\icpp{make_tuple}), qui nous permettra de construire des
\icpp{_tuple} sans devoir spécifier le type de chacun des éléments.
La raison pour laquelle on hérite de tous les \icpp{_element}s dans
\icpp{_tuple} et que cela nous permet d'accéder à chaque élément individuel
grâce à l'astuce suivante:
\begin{cpp}
    template <int i, typename T>
    T get(_element<i, T> e) {
        return e.value;
    }

    char y = get<3>(make_tuple('x', 'y', 'z'));
\end{cpp}

Puisque \icpp{_tuple} hérite de tous les \icpp{_element}s, il existe une
conversion de \icpp{_tuple} vers n'importe laquelle de ses classes de base.
Ensuite, puisqu'on fixe le \icpp{i} explicitement en appelant \icpp{get<i>},
le compilateur constate que la seule signature possible pour \icpp{get} est
\icpp{char get(_element<3, char>)}. Il suffit ensuite de retourner la valeur
associée à cet élément. En bref, on a donc que
\icpp{get<i>(make_tuple(x1, ..., xn)) == xi}.

Étant donné une séquence d'objets $x_1, \hdots, x_n$ de type généralisé $X$,
on dénotera par $Tuple(X)$ le type généralisé de \icpp{make_tuple(x1, ..., xn)}.
De cette manière, on considérera $Tuple$ comme un type généralisé paramétré,
où le paramètre représente le type généralisé des éléments que le $Tuple$
contient. On notera en passant qu'il serait possible de stocker des éléments
ayant des types généralisés différents au sein d'un même \icpp{_tuple}, puisque
\icpp{_tuple} ne pose aucune restriction sur le type de ces éléments. Cependant,
on restreindra notre étude aux \icpp{_tuple}s qui contiennent tous des éléments
d'un même type généralisé, puisque c'est ceux-là qui nous donnent les propriétés
les plus intéressantes.

Nous sommes maintenant en mesure de formuler concrètement le problème initial
qui était d'appliquer une fonction à chaque élément d'une séquence. Étant
donné une fonction $f : X \to Y$ et une séquence \icpp{make_tuple(x1, ..., xn)}
de type généralisé $Tuple(X)$, on aimerait obtenir une séquence
\icpp{make_tuple(f(x1), ..., f(xn))} (de type généralisé $Tuple(Y)$).
Voici comment on pourrait faire ceci:
\begin{cpp}
    template <typename T1, ..., typename Tn, typename F>
    auto transform(_tuple<T1, ..., Tn> ts, F f) {
        return make_tuple(f(get<0>(ts)), ..., f(get<n-1>(ts)));
    }
\end{cpp}

Étant donné une séquence d'objets sous la forme d'un \icpp{_tuple}, on
applique simplement \icpp{f} à chaque élément (extrait avec \icpp{get}),
puis on retourne une nouvelle séquence qui contient le résultat. À ce
point-ci, le foncteur caché sous le tapis devrait commencer à être évident.

En effet, en tant que foncteur, \icpp{Tuple} associe à tout objet $X$ de $Hana$
un nouvel objet $Tuple(X)$ représentant une séquence d'éléments de type $X$,
et à toute flèche $f : X \to Y$ une nouvelle flèche $\icpp{transform(-, f)} :
Tuple(X) \to Tuple(Y)$, qui consiste à appliquer $f$ à chaque élément d'une
telle séquence.

Démontrons maintenant que \icpp{Tuple} est bien un foncteur. D'abord, étant
donné un objet quelconque \icpp{xs} de type généralisé \icpp{Tuple(X)},
appliquer \icpp{transform} à \icpp{xs} et la fonction identité sur $X$
ne change pas \icpp{xs} du tout. En effet, en supposant que \icpp{xs}
contienne $n$ éléments, on a alors
\begin{cpp}
    transform(xs, id) == make_tuple(id(get<0>(xs)), ..., id(get<n-1>(xs)))
                      == make_tuple(get<0>(xs), ..., get<n-1>(xs))
                      == xs
\end{cpp}

Ainsi, on a bien que \icpp{transform(-, id) == id}, et \icpp{Tuple} respecte
donc les flèches identités. Il reste à montrer que \icpp{Tuple} respecte la
loi de composition, c'est-à-dire que pour toutes fonctions $f : X \to Y$ et
$g : Y \to Z$, on a
\begin{cpp}
    transform(transform(xs, f), g) == transform(xs, compose(g, f))
\end{cpp}

Or, on trouve facilement que
\begin{cpp}
    transform(transform(xs, f), g)
        == transform(make_tuple(f(get<0>(xs)), ..., f(get<n-1>(xs))), g)
        == make_tuple(g(f(get<0>(xs))), ..., g(f(get<n-1>(xs))))
        == make_tuple(compose(g, f)(get<0>(xs)), ..., compose(g, f)(get<n-1>(xs)))
        == transform(xs, compose(g, f))
\end{cpp}

ce qui montre que la loi de composition est bien respectée. Le fait d'exiger
que \icpp{Tuple} soit un foncteur est bien plus qu'un simple caprice de
mathématicien. En effet, exiger que la composition soit respectée par
\icpp{transform} permet de faire des optimisations pour éliminer des
structures temporaires inutiles. Par exemple, lorsque l'on applique
\begin{cpp}
    transform(transform(xs, f), g)
\end{cpp}

alors un \icpp{_tuple} intermédiaire qui contient \icpp{transform(xs, f)} doit
être créé, puis envoyé aux deuxième \icpp{transform}. Si les objets retournés
par \icpp{f} sont coûteux à copier, ceci peut représenter un problème. Or, la
loi des foncteurs nous dit qu'on peut réécrire cette ligne comme
\icpp{transform(xs, compose(g, f))}, qui ne crée pas de structure
temporaire inutile.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Sections optionnelles
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{comment}
\subsection{Le foncteur Lazy}
Une propriété intéressante de certains langages de programmation fonctionnelle
est l'évaluation paresseuse. L'évaluation paresseuse est le principe selon
lequel la valeur d'une expression n'est pas calculée tant que celle-ci n'est
pas utilisée. Par exemple, en C++, si on écrit
\begin{cpp}

\end{cpp}

alors xyz est toujours calculée, même si elle n'est en fait pas utilisée. Au
contraire, en Haskell, lorsqu'on écrit
\begin{minted}{haskell}

\end{minted}

alors xyz n'est jamais appelée, puisque son résultat n'est jamais utilisé.
La capacité de contrôler quand une expression est évaluée peut être une chose
très importante, par exemple lorsqu'on désire implémenter un langage dédié
dans lequel il y a une notion de branchement. En effet, il sera alors
nécessaire de contrôler laquelle des deux branches est évaluée, et quand
celle-ci est évaluée. Bien que le C++ ne permette pas ce genre de contrôle
de manière native, il est possible de créer une couche d'abstraction qui
permet d'émuler l'évaluation paresseuse. De plus, comme nous le verrons
ici, cette abstraction aura des qualités fonctorielles (et même bien plus).


\subsection{Le foncteur Type}

\todo{
    Introduire le foncteur Type, qui n'est pas un endofoncteur.
    Étudier les propriétés d'injectivité du foncteur pour prouver
    que tout ce qui peut être fait dans MPL peut être fait dans Hana.
}

\end{comment}
