\section{Les foncteurs}
Nous avons introduit la notion de catégorie à l'aide d'exemples provenant de
l'algèbre abstraite, de l'analyse puis de l'informatique. L'algorithme pour
\textit{catégoriser} une théorie était toujours un peu le même: isoler les
objets d'étude de la théorie, isoler les propriétés importantes qui les
définissent puis considérer l'ensemble des transformations qui, de manière
informelle, respectent ces propriétés. Or, la théorie des catégorie est
elle-même une théorie qui étudie certains objets appelés ``catégories''.
Il serait donc naturel de se demander s'il est possible de définir des
transformations entre les catégories et, si c'est le cas, quelles propriétés
doivent posséder ces transformations pour qu'on obtienne quelque chose
d'intéressant. Comme on s'apprête à le voir, ce questionnement et sa
réponse sont à la source de la notion de \textit{foncteur}, qui n'est
en effet rien d'autre qu'une transformation entre catégories.

D'abord, une catégorie $\C$ possède non seulement des objets, mais aussi
des flèches entre ces objets. Ainsi, peu importe la forme que prendra notre
transformation inter-catégories, elle devra spécifier où elle envoie les
objets, mais aussi les flèches. Considérons donc une application $F : \C \to \D$
d'une catégorie $\C$ vers une catégorie $\D$. On devra avoir que pour chaque
objet $A \in \ob(\C)$, $F$ envoie $A$ vers un objet de $\D$, disons
$F(A) \in \ob(\D)$. De manière similaire, pour chaque flèche
$f : A \to B \in \hom(\C)$, $F$ devra envoyer $f$ sur une flèche
de $\D$, disons $F(f) \in \hom(\D)$.

Il est intéressant de remarquer que l'on a pas spécifié la source ni la
destination de la flèche $F(f)$. En fait, pour une flèche $f : A \to B$,
seuls deux choix s'offrent à nous: soit $F(f) : F(A) \to F(B)$, soit
$F(f) : F(B) \to F(A)$. Ces deux choix sont valables. Dans le premier cas,
on dira que c'est un foncteur \textit{covariant}, ou juste un foncteur, et
dans l'autre cas on dira que c'est un foncteur \textit{contravariant}. Dans
le cadre actuel, nous nous intéresserons seulement aux foncteurs covariants.

Ensuite, une catégorie possède une loi de composition et chaque objet doit
posséder une flèche identité; il serait probablement intéressant qu'une
transformation entre catégories préserve ces propriétés d'une certaine manière.
On demandera donc que la loi de composition soit respectée, c'est-à-dire que
pour des flèches $f : A \to B$ et $g : B \to C$ de $\C$,
\[
    F(g \circ_\C f) = F(g) \circ_\D F(f)
\]

De manière similaire, on demandera que les flèches identité soient préservées
par la transformation, c'est-à-dire que pour un objet $A$ de $\C$, on devra
avoir
\[
    F(id_A) = id_{F(A)}
\]

Ceci nous mène à la définition formelle suivante:

\begin{définition}[Foncteur]
    Un foncteur $F : \C \to \D$ d'une catégorie $\C$ vers une catégorie $\D$
    est une application qui
    \begin{enumerate}
        \item à chaque objet $X \in \ob(\C)$ associe un objet $F(X) \in \ob(\D)$
        \item à chaque flèche $f : A \to B \in \hom(\C)$ associe une flèche
              $F(f) : F(A) \to F(B) \in \hom(\D)$
        \item respecte la loi de composition, c'est-à-dire que pour toutes
              flèches $f : A \to B$ et $g : B \to C \in \hom(\C)$,
              $F(g \circ_\C f) = F(g) \circ_\D F(f)$
        \item préserve les identités, c'est-à-dire que pour tout objet
              $X \in \ob(\C)$, $F(\id_X) = \id_{F(X)}$
    \end{enumerate}
\end{définition}

Lorsque le domaine et le codomaine d'un foncteur sont la même catégorie, i.e.
lorsqu'on a un foncteur du type $F : \C \to \C$ pour une certaine catégorie
$\C$, on dira parfois que $F$ est un \textit{endofoncteur}.

\todo{Intuition et diagramme commutatif pour expliquer le respect de la
loi de composition}

\subsection{Les foncteurs dans Hana}
Dans le cadre de la bibliothèque Hana, on s'intéressera principalement aux
endofoncteurs sur la catégorie Hana, c'est-à-dire aux foncteurs du type
$F : Hana \to Hana$. D'abord, rappelons-nous que les objets de la catégorie
Hana sont des types généralisés. Un foncteur $F$ devra donc envoyer un type
généralisé $T$ vers un autre type généralisé $F(T)$. Ensuite, les flèches de
Hana sont des fonctions dont le domaine et le codomaine sont des types
généralisés. Ainsi, un foncteur $F$ devra envoyer une telle fonction
$f : T \to U$ vers une fonction $F(f) : F(T) \to F(U)$. Dans Hana, un
foncteur se matérialise comme un type généralisé paramétré et muni d'une
fonction appelée \icpp{transform} ayant la pseudo-signature suivante:
\[
    \icpp{transform} : F(T) \times (T \to U) \to F(U)
\]

Si un type généralisé paramétré $F$ est un foncteur au sens de Hana, alors
$F(T)$ est le type généralisé correspondant à l'image de $T$ par le foncteur
$F$. Cependant, le rôle de \icpp{transform} demande un peu plus de
justification. On notera que l'ordre des paramètres de \icpp{transform} est
fâcheux pour l'explication qui suit. C'est tout de même cet ordre qui est
utilisé dans Hana parce qu'il est avantageux lorsqu'on veut passer une
fonction anonyme C++ à \icpp{transform}. On commence donc par échanger
l'ordre des paramètres de \icpp{transform} en considérant plutôt la
fonction \icpp{transform_}:
\begin{align*}
    \icpp{transform_} : (T \to U) \times F(T) &\to F(U)     \\
                           \icpp{(f, xs)}     &\mapsto \icpp{transform(xs, f)}
\end{align*}

Supposons maintenant que l'on ait une fonction $f : T \to U$. On peut
appliquer partiellement $f$ à \icpp{transform_} pour obtenir la
fonction
\[
    \icpp{transform_(f)} : F(T) \to F(U)
\]

On peut remarquer que \icpp{transform_(f)} possède la signature requise
pour être l'image d'une flèche de Hana par le foncteur $F$. Dans la catégorie
Hana, un foncteur $F$ envoie donc un type généralisé $T$ sur un nouveau type
généralisé $U$, et une fonction $f : T \to U$ sur une nouvelle fonction
$\icpp{transform_(f)} : F(T) \to F(U)$. Bien entendu, pour qu'il s'agisse
bien d'un foncteur, certaines propriétés doivent être respectées. D'abord,
le foncteur doit respecter la loi de composition de Hana, i.e. pour toutes
fonctions $f : A \to B$ et $g : B \to C$, on doit avoir que
$F(g \circ f) = F(g) \circ F(f)$.

Dans Hana, ceci devient simplement
\[
    \icpp{transform_(g} \circ \icpp{f)} = \icpp{transform_(g)} \circ \icpp{transform_(f)},
\]

ce qui est équivalent à dire que pour tout \icpp{xs} de type généralisé $F(T)$,
\[
    \icpp{transform(xs, g} \circ \icpp{f)} = \icpp{transform(transform(xs, f), g)}
\]

Ensuite, le foncteur doit aussi respecter l'identité, c'est à dire que
$F(\id_T) = \id_{F(T)}$. Dans Hana, puisque l'identité est une fonction
générique qui fonctionne sur tous les types généralisés, ceci se traduit
simplement par
\[
    \icpp{transform_(id)} = \icpp{id},
\]

ce qui est équivalent à dire que pour tout \icpp{xs} de type généralisé $F(T)$,
\[
    \icpp{transform(xs, id)} = \icpp{xs}
\]

Voyons maintenant comment certaines structures fournies par Hana peuvent
être vues comme des foncteurs.


\subsection{Le foncteur Maybe}

\todo{Introduire le foncteur Maybe sur des types généralisés}

\subsection{Le foncteur Lazy}

\todo{Introduire le foncteur Lazy sur des types généralisés}

\subsection{Le foncteur Type}

\todo{
    Introduire le foncteur Type, qui n'est pas un endofoncteur.
    Étudier les propriétés d'injectivité du foncteur pour prouver
    que tout ce qui peut être fait dans MPL peut être fait dans Hana.
}


\subsection{Le foncteur Tuple}
Un tuple peut être vu comme un foncteur d'au moins deux manières. D'abord,
on peut voir un tuple à deux éléments comme un foncteur de la manière suivante.
On commence par fixer le type d'un des deux éléments du tuple. On a donc un
type partiellement formé $(A, -)$ qu'on pourrait ensuite appliquer à un
deuxième type $B$ pour obtenir $(A, B)$. Ensuite, étant donné une fonction
$f : B \to C$, on peut donner la fonction
\begin{align*}
    snd(f) : (A, B) &\to (A, C)             \\
             (a, b) &\mapsto (a, f(b))
\end{align*}

Ainsi, on peut voir le type partiellement formé $(A, -)$ comme un foncteur,
qui associe à tout type $B$ le type $(A, B)$ et à toute fonction $f : B \to C$
la fonction $snd(f) : (A, B) \to (A, C)$. Il est facile de vérifier que les
propriétés d'un foncteur sont respectées. Cette manière de voir les tuples
a son utilité, mais Hana les voit d'une autre manière qui est plus utile à
des fins de métaprogrammation. On aimerait voir un tuple comme une séquence
de taille fixe contenant des éléments d'un certain type $T$, qui est indéterminé
pour l'instant. Puisqu'on aurait une séquence homogène contenant des éléments
de type $T$, il serait possible d'appliquer une fonction (dont le domaine est
$T$) à chaque élément de la séquence pour d'obtenir une nouvelle séquence
contenant les résultats. En tant que foncteur, une telle séquence pourrait
donc associer à tout objet $A$ de $Hana$ un nouvel objet $[A]$ représentant
une séquence d'éléments de type $A$, et à toute flèche $f : A \to B$ une
nouvelle flèche $\icpp{transform(-, f)} : [A] \to [B]$, qui consisterait à
appliquer $f$ à chaque élément d'une séquence, ce qui constitue une opération
très utile en programmation. Notre but est donc de trouver une manière
mathématiquement rigoureuse d'inscrire la notion de tuple dans cette notion
de foncteur, que nous savons à la fois productive, utile pour raisonner à
propos des programmes et intuitive pour les habitués de la métaprogrammation.

Pour comprendre comment Hana s'y prend, on peut se poser la question suivante.
Étant donné un tuple $(T_1, \hdots, T_n)$ et une fonction $f$ dont le domaine
n'est pas encore fixé, quel devrait être le domaine de $f$ pour qu'elle puisse
être appliquée à tous les éléments du tuple? Il va sans dire que ce domaine
devrait être au moins aussi général que les types de tous les éléments du
tuple, sans quoi l'application de $f$ à certains éléments serait mal définie.
Cependant, un domaine trop général --- par exemple l'ensemble de tous les types
possibles --- ne donnerait pas assez d'information à la fonction pour qu'elle
puisse manipuler ses entrées de manière utile. Le but serait donc de déterminer
le domaine le plus spécifique --- donc fournissant le plus d'information sur
les éléments du tuple --- qui serait au moins aussi général que tous les types
du tuple. Or, puisque nous travaillons avec des tuples de taille finie, ce type
est facile à spécifier; il s'agit simplement de l'union des types du tuple,
qu'on appelle généralement \icpp{variant} en C++. Ainsi, étant donné un tuple
$(T_1, \hdots, T_n)$, le domaine le plus spécifique de $f$ devrait simplement
être $\bigcup_{k=1}^n T_k$! Dans Hana, à des fins de fonctorialité, on
considérera donc un tuple \icpp{Tuple(T1, ..., Tn)} comme un tableau de
taille fixe contenant des éléments d'un type \icpp{variant}, c'est-à-dire
\icpp{array<variant<T1, ..., Tn>, n>}. Pour appliquer une fonction à chaque
élément d'une telle séquence, on devra définir une fonction dont le domaine
est l'union de tous les $T_k$. Or, il se trouve que le C++ fournit un outil
très commode pour définir de telles fonctions; il s'agit de
l'\textit{overloading}.

\todo{
    Exemples d'utilisation et justifier rigoureusement le fait qu'on ne prend
    pas un variant<...> dans la fonction.
}

Bien entendu, cette vision des choses n'est pas parfaite. En effet, elle
nous fait perdre certaines propriétés très utiles des tuples, mais nous en
fait gagner d'autres. D'abord, à des fins de fonctorialité, les types
\icpp{Tuple(T1, T2, ..., Tn)} et \icpp{Tuple(T2, T1, ..., Tn)} sont
équivalents, puisqu'on les interpète tous deux comme
\icpp{array<variant<T1, T2, ..., Tn>, n>}. On a donc perdu l'information du
type de l'objet qui se trouve à un index donné. De plus, on a aussi perdu
l'information du nombre de types différents dans un tuple. En effet, les
types \icpp{Tuple(T, U)} et \icpp{Tuple(U, T)} sont maintenant tous les
deux vus comme des \icpp{array<variant<T, U>, 2>}. Cependant, il est
maintenant possible d'appliquer une fonction à chaque élément d'un
tuple et d'obtenir un nouveau tuple qui contient les résultats.

\todo{
    1. Expliquer pourquoi on ne considère pas l'avenue des n-multifoncteurs.
    2. Expliquer ce que ça nous donne d'avoir que les tuples sont des foncteurs.
       En particulier, ça nous donne que transform(transform(xs, f), g) ==
       transform(xs, g . f). Ça ouvre aussi la porte aux foncteurs applicatifs
       et aux monades.
}



\begin{comment}
Ensuite, supposons qu'on veut ordonner deux tuples. Quand est-ce que ça
fait du sens de faire ça? Pour répondre à cette question, on commence
par voir le tuple comme un array de variants. Ensuite, il suffit de faire
une comparaison lexicographique standard sur cet array. Le problème devient
donc de savoir comment on peut comparer deux variants. La nouvelle question
se formule ainsi: Étant donné deux variants<T1, ..., Tn>, quand est-ce
qu'il fait du sens d'ordonner ces variants. Pour nous faciliter la vie,
on commence par réduire le problème en ne considérant que des variants
binaires, c'est-à-dire des variants de la forme variant<T, U>. On ne perd
aucune généralité parce qu'un variant n-aire variant<T1, ..., Tn> est
équivalent à un variant binaire variant<T1, variant<T2, ..., Tn>>.
La question est maintenant beaucoup plus simple: étant donné deux
variants variant<T, U>, quand est-ce qu'il fait du sens de les comparer?
Il se trouve que j'ai déjà la réponse dans Hana avec les cross-type
operations!
    >> Ok, pas certain qu'on veuille orderer les tuples comme des arrays de
    >> variants. C'est peut-être mieux de juste les regarder comme des tuples
    >> normaux.


Ensuite, on peut faire le pont avec Hana en disant simplement que Hana
considère qu'une fonction sur un variant connu au moment de la compilation
n'est rien d'autre qu'une fonction overloadée, et que hana::_tuple est un
array de variants qui est super optimisé pour les cas où on connaît
ce qui est contenu dans chaque variant de l'array au moment de la
compilation.
\end{comment}



%%%%%%%%%%%%%%%%%%%%%%% Ici je patauge un peu %%%%%%%%%%%%%%%%%%%%%%%
\begin{comment}
Étant donné une collection de types généralisés $T_1, \hdots, T_n$,
il est toujours possible de synthétiser un nouveau type généralisé
$Common(T_1, \hdots, T_n)$ qu'on peut voir comme ``la plus petite
généralisation'' des types $T_1, \hdots, T_n$. Puisque l'interface
d'un type généralisé est représenté dans Hana par l'ensemble des
concepts dont ce type est un modèle, on aimerait donc que ce nouveau
type $Common(T_1, \hdots, T_n)$ possède l'interface qui est commun à
tous les $T_k$. En d'autres mots, l'ensemble des concepts dont le type
$Common(T_1, \hdots, T_n)$ est un modèle est:
\[
    Concepts(Common(T_1, \hdots, T_n)) := \bigcap_{k=1}^n Concepts(T_k)
\]

De plus, il est très facile de représenter le type généralisé
$Common(T_1, \hdots, T_n)$ en C++. Nous n'avons qu'à utiliser
les \textit{templates}:
\begin{cpp}
    template <typename ...Tn>
    struct Common { };
\end{cpp}

De cette manière, étant donné des types généralisés \icpp{T1}, ..., \icpp{Tn},
leur plus petite généralisation est représentée par le nouveau type généralisé
\icpp{Common<T1, ..., Tn>}. Ensuite, étant donné des objets $x_1, \hdots, x_n$
de types généralisés $T_1, \hdots, T_n$, il est facile de créer une nouvelle
séquence d'objets $y_1, \hdots y_n$ qui ont tous le même type généralisé
$Common(T_1, \hdots, T_n)$. Encore une fois, le truc est d'utiliser les
\textit{templates}:
\begin{cpp}
    template <typename X, typename ...Tn>
    struct wrapper {
        X value;
        struct hana { using datatype = Common<Tn...>; };
    };
\end{cpp}

On aura alors que
\begin{cpp}
    y_k = wrapper<decltype(x_k), T1, ..., Tn>{x_k}
\end{cpp}


%%%%%%%%%%%%%%%%% Tentative 1 avec des wrappers
Quand tu te crées un tuple, on prend le Common de tous les types que tu mets dedans.
Ensuite, on wrap tous tes objets dans wrapper<...>. Vu que c'est de la marde de recevoir
des wrapper<...>, on t'envoie le wrapper<...>.value au lieu dans toutes tes méthodes.
C'est OK de faire ça, parce que pour chaque objet x, l'instance d'un concept
C par wrapper est isomorphe avec l'instance du concept C pour x. L'isomorphisme
est unique (wrapper<...>{x} <-> wrapper<...>{x}.value). Attention: pour mieux
comprendre ceci, il faudrait considérer qu'on envoie des wrapper<...> à nos
fonctions et qu'elle ne sont pas capable de les unwrapper, juste d'utiliser
les instances que le wrapper fournit.

HMMM, attention. Dans la réalité, les fonctions qui manipuleraient des Wrappers
ne pourraient pas utiliser le .value, juste le wrapper lui-même. Ça serait OK
parce que de toute façon le wrapper fournit exactement les modèles qui sont
possible de provider. Cependant, qu'est-ce qui prouve que le fait d'accéder
au .value préserve ces modèles exactement??? Il faut que le modèle qui est
implémenté par le wrapper soit uniquement isomorphe au modèle du .value (? vérifier).
Par le fait même, ceci requiert que tous les modèles tes T1, ..., Tn soient
uniquement isomorphes.

Étant donné des foncteurs F1 et F2, s'il existe un unique iso de foncteurs
entre F1 et F2, alors on peut réduire F1 et F2 à (disons) F1 SPDG. Ensuite,
on est simplement de retour à traiter un simple foncteur F1. Après, il est
facile de créer un wrapper tel que Wrapper(F1) est un foncteur uniquement
isomorphe à F1, et on fait le wrapping/unwrapping automatiquement pour
simplifier la job de l'utilisateur.
\end{comment}
