\section{La métaprogrammation en C++}

\subsection{Le système de typage et les templates}
Cette section introduit brièvement les concepts de base du système de typage
du C++, qui seront nécessaires par la suite. Le lecteur qui est familier avec
le C++11 et le C++14 est invité à sauter cette section.

Le C++ est un langage statiquement typé. Ceci veut dire que chaque objet
possède un (et un seul) type, et que celui-ci est déterminé au moment de la
compilation. De plus, en C++, le type d'un objet est directement relié à son
mode de représentation. Par exemple, pour représenter une valeur entière, on
doit d'abord décider d'un mode de représentation, disons {\tt int}. Or, le mode
de représentation choisit ne permet généralement pas de représenter le concept
voulu dans toute sa généralité. En effet, {\tt int} n'est capable de représenter
que des valeurs entre -2,147,483,647 et 2,147,483,647, ce qui est très loin
du très général $\mathbb{Z}$. La différence entre le concept abstrait
représenté par un type et sa représentation concrète est un problème auquel
les programmeurs sont constamment confrontés. Un bon programmeur saura
utiliser la bonne représentation au bon moment, et ce dans le but d'optimiser
des choses qui dépendent de la situation particulière; performance,
expressivité, testabilité ou même productivité du programmeur.

Lorsqu'on souhaite créer un objet pour lui donner une valeur, on doit donc
dire au compilateur quel est le mode de représentation que l'on souhaite
utiliser. Par exemple, pour créer un entier représenté par le type {\tt int}
avec une valeur de 10, on écrira
\begin{minted}{c++}
    int i = 10;
\end{minted}

De manière similaire, le domaine et le codomaine d'une fonction sont des
types qui doivent être connus au moment de la compilation. Ici aussi, il
est nécessaire de spécifier le mode de représentation exact que l'on souhaite
utiliser. Par exemple, pour déclarer une fonction dont le domaine est
l'ensemble des chaînes de caractères et le codomaine est l'ensemble des
entiers non-négatifs, on devra d'abord décider d'une représentation concrète
pour chacun de ces ensembles. Supposons que l'on choisisse le type
{\tt std::string} pour représenter l'ensemble des chaînes de caractères et le
type {\tt unsigned int} pour représenter l'ensemble des entiers non-négatifs.
Une fonction $f : \text{{\tt std::string}} \to \text{{\tt unsigned int}}$
s'écrira alors
\begin{minted}{c++}
    unsigned int f(std::string);
\end{minted}

Les créateurs du langage C++ se sont vite rendu compte que ce système,
bien que plutôt simple à gérer pour le compilateur, limitait grandement
l'expressivité du côté du programmeur. Par exemple, supposons que l'on
ait une famille de types représentant des séquences d'objets, et que ces
types aient tous un interface commun:

\begin{minted}{c++}
    struct int_sequence {
        bool is_empty() const;
        int head() const;
        int_sequence tail() const;

        // implémentation ignorée pour simplifier
    };

    struct float_sequence {
        bool is_empty() const;
        float head() const;
        float_sequence tail() const;

        // implémentation ignorée pour simplifier
    };

    // possiblement d'autres types de séquences
\end{minted}

Dans cet exemple, {\tt is\_empty} retourne une valeur booléenne qui est {\tt true}
si la séquence est vide, et {\tt false} sinon. {\tt head} retourne la première
valeur d'une séquence non-vide et {\tt tail} retourne une nouvelle séquence
qui contient toutes les valeurs sauf la première. À partir de cet interface
minimal, il est possible de faire plusieurs choses utiles. Par exemple, on
peut aller chercher la n-ième valeur dans une séquence de la manière suivante:
\begin{minted}{c++}
    int_sequence int_sequence_nth_element(unsigned int n, int_sequence s) {
        if (n == 0) return s.head();
        else        return int_sequence_nth_element(n - 1, s.tail());
    }
\end{minted}

Malheureusement, cette fonction ne fonctionne que sur des objets de type
{\tt int\_sequence}. Il faudrait donc écrire une autre fonction pour les
objets de type {\tt float\_sequence}
\begin{minted}{c++}
    float_sequence float_sequence_nth_element(unsigned int n, float_sequence s) {
        if (n == 0) return s.head();
        else        return float_sequence_nth_element(n - 1, s.tail());
    }
\end{minted}

Évidemment, l'implémentation de la fonction est exactement la même; la seule
différence est le type des objets qui sont manipulés. Ceci est fâcheux puisqu'il
s'agit d'une duplication d'efforts qui doit être effectuée à chaque fois qu'une
nouvelle représentation pour une séquence d'un type différent est ajoutée. Les
\textit{templates} servent à éliminer ce problème. Au lieu de spécifier exactement
la représentation du domaine d'une fonction, on peut utiliser un type fictif de la
manière suivante:
\begin{minted}{c++}
    template <typename Sequence>
    Sequence nth_element(unsigned int n, Sequence s) {
        if (n == 0) return s.head();
        else        return nth_element(n - 1, s.tail());
    }
\end{minted}

Ensuite, le compilateur s'occupera lui-même de substituer les bons types puis
de générer la fonction appropriée. Par exemple, lorsque le compilateur voit le
code suivant
\begin{minted}{c++}
    int_sequence s = ...;
    int i = nth_element(10, s);
\end{minted}

, il commence par déterminer quel est le type qui devrait être substitué à
la place de {\tt Sequence} dans le template écrit plus haut. Il détermine
que le type à substituer est {\tt int\_sequence}, puis il génère une fonction
équivalente à celle que nous avions écrite pour le type {\tt int\_sequence}.
Finalement, l'appel à {\tt nth\_element} sera en réalité un appel à la
fonction générée pour le type {\tt int\_sequence}. L'idée est donc
d'utiliser le compilateur comme un système de réécriture pour nous
éviter des tâches répétitives dans certains cas. Cependant, il reste un cas
très évident de répétition dans l'exemple que nous venons de donner; les
séquences sont une famille de types qui possèdent tous un interface similaire
et dont l'implémentation pourrait être similaire, mais nous avons quand même
répété exactement le même code pour chacun de ces types. Heureusement, les
templates peuvent aussi être utilisés pour créer des canevas de types:
\begin{minted}{c++}
    template <typename T>
    struct sequence {
        bool is_empty() const;
        T head() const;
        sequence<T> tail() const;

        // implémentation ignorée pour simplifier
    };
\end{minted}

Ensuite, on aura qu'à écrire {\tt sequence<int>} pour faire référence à la
représentation d'une séquence contenant des {\tt int}, {\tt sequence<float>}
pour une séquence de {\tt float}, et ainsi de suite. Par exemple, lorsque le
compilateur voit
\begin{minted}{c++}
    sequence<float> s = ...;
\end{minted}

, il génère un type équivalent à {\tt float\_sequence} en substituant {\tt T}
par {\tt float} dans le canevas écrit plus haut, et c'est à ce type généré que
l'écriture {\tt sequence<float>} fait référence.

Dans la réalité, il arrive souvent que l'on souhaite écrire une fonction
template qui ait une implémentation bien spécifique pour certains types
d'arguments, ou encore un type template qui ait une représentation spéciale
dans certains cas. Ceci est particulièrement utile à des fins d'optimisation.
Par exemple, supposons que nous voulions représenter une séquence de booléens.
Nous pouvons utiliser le type {\tt sequence<bool>}. Cependant, en supposant
que {\tt sequence} stocke ses valeurs dans un tableau d'éléments contigus en
mémoire, on peut remarquer qu'une représentation différente nous ferait sauver
de l'espace. En effet, le type {\tt bool} prend généralement 1 octet en mémoire
parce qu'il s'agit de la petite unité adressable, mais nous n'avons en réalité
besoin que d'une seule bit pour le représenter. Si on voulait stocker une
séquence de booléens, on pourrait utiliser un tableau d'octets et n'utiliser
qu'une seule bit par booléen. Le C++ rend ce genre d'optimisation très facile
à implémenter en utilisant une technique appelée \textit{spécialisation}:
\begin{minted}{c++}
    template <>
    struct sequence<bool> {
        bool is_empty() const;
        bool head() const;
        sequence<bool> tail() const;

        // on pourrait spécifier ici une représentation plus efficace
    };
\end{minted}

Avec une telle spécialisation, le type {\tt sequence<T>} fait référence à
l'implémentation pour le cas général présenté au début de cette section,
mais le type {\tt sequence<bool>} fait référence à la représentation plus
efficace qu'on vient de donner. De plus, tant qu'on ne change pas l'interface
publique du type {\tt sequence<bool>} en le spécialisant, toutes les fonctions
qui n'utilisent que cet interface (comme {\tt nth\_element}) fonctionneront
encore. Cependant, il arrive fréquemment qu'il est possible d'implémenter une
fonction de manière plus efficace si l'on tire avantage de la représentation
d'un type. Le C++ permet donc aussi de spécifier une implémentation différente
pour une fonction à l'aide d'une technique appelée \textit{overloading}. Par
exemple, on pourrait spécifier l'implémentation de la fonction
{\tt nth\_element} pour le type {\tt sequence<bool>} comme suit:
\begin{minted}{c++}
    sequence<bool> nth_element(unsigned int n, sequence<bool> s) {
        // implémentation plus efficace
    }
\end{minted}

Lorsque le compilateur voit un appel à la fonction {\tt nth\_element}, il
effectue un procédé plutôt complexe appelé \textit{overload resolution}, qui
consiste essentiellement à trouver la version de {\tt nth\_element} qui est
la plus spécifique étant donné le type des arguments avec lesquels la fonction
est appelée.

Le dernier élément de base dont nous aurons besoin pour la suite est la
déduction automatique du type d'une expression, qui a été introduite dans
le langage en 2011. En C++, toute expression possède un type unique qui est
connu par le compilateur. En principe, le compilateur devrait donc être
capable de dire ce type au programmeur. C'est en effet le cas; il suffit
d'utiliser le mot clé {\tt decltype}. Par exemple, pour savoir le type de
l'expression {\tt 1 + 1}, on peut écrire {\tt decltype(1 + 1)}:
\begin{minted}{c++}
    // équivalent à `int i = 0`, parce que `decltype(1 + 1) = int`
    decltype(1 + 1) i = 0;
\end{minted}

De plus, il est possible de demander au compilateur de donner à une variable
le type inféré d'une expression qu'on lui assigne. Pour ce faire, on utilise
le mot clé {\tt auto}:
\begin{minted}{c++}
    auto i = 1 + 1;
\end{minted}

Ici, le compilateur détermine que le type de {\tt 1 + 1} est {\tt int}, et
le type de {\tt i} est donc {\tt int}, exactement comme si on avait écrit
{\tt int i = 1 + 1}. Ce principe s'étend aussi au type de retour des fonctions.
En effet, le compilateur peut inférer le type de retour d'une fonction à partir
du type de l'expression qui est retournée. Par exemple, pour prendre un exemple
un peu trivial,
\begin{minted}{c++}
    auto add(int i, int j) {
        return i + j;
    }
\end{minted}

Ici, le compilateur sait que {\tt i} et {\tt j} sont de type {\tt int},
puisque c'est comme cela qu'ils ont été déclarés comme paramètres de la
fonction {\tt add}. De plus, il sait que l'addition de deux {\tt int} donne
un {\tt int}; il peut donc inférer le type de retour de la fonction {\tt add}
comme étant le type {\tt int}.

Bien que ces mots clés n'en aient pas l'air, ils sont terriblement utiles pour
faire de la programmation générique. Par exemple, si on changeait la définition
de {\tt add} pour
\begin{minted}{c++}
    template <typename T, typename U>
    auto add(T t, U u) {
        return t + u;
    }
\end{minted}

, le type de retour serait bien moins évident. Par exemple, si on appelle la
fonction {\tt add} avec une {\tt std::string} et un {\tt char const*}, il
n'est pas du tout évident que le type de retour doit être {\tt std::string}.
    \footnote{En effet, le fichier {\tt <string>} fournit un opérateur avec la
    signature {\tt std::string operator+(std::string, char const*)}, qui sera
    utilisé ici.}
En général, il sera très difficile ou même impossible pour un programmeur
d'écrire explicitement le type d'une expression lorsque celui-ci dépend de
plusieurs autres expressions dont les types sont inconnus par le programmeur.


\subsection{La métaprogrammation dans Hana}




% introduire la spécialisation pour le branching compile-time
% introduire la récursion compile-time et dire que c'est turing complet

% montrer comment on peut représenter des valeurs compile-time en utilisant
% des objets de type singleton, et comment ça joue avec le return type deduction.

% Montrer comment on peut implémenter un tuple et un exemple d'utilisation pour
% faire quelque chose d'utile.

% Introduire la notion de generalized data type et faire le lien avec la
% dichotomie "abstract data type"/"representation".
