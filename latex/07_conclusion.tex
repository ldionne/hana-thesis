\section{Conclusion}
Nous avons introduit les concepts de base de la métaprogrammation en C++, puis
nous avons présenté certains outils qui permettent de faire des calculs au
moment de la compilation. Nous avons ensuite introduit des concepts de base
de la théorie des catégories en insistant sur l'intuition, puis nous avons
présenté une formalisation de la métaprogrammation à l'aide de ces notions.
Finalement, nous avons montré comment cette formalisation peut aider à obtenir
des interfaces expressives et composables à l'aide d'exemples concrets.

Les contributions originales de ce travail sont l'introduction d'un système
permettant d'exprimer des calculs au moment de la compilation avec la
même syntaxe que le C++ usuel, la représentation de l'univers de la
métaprogrammation statique à l'aide d'une catégorie, ainsi que l'observation
que le phénomène de \textit{SFINAE} peut être modélisé à l'aide d'une monade
de gestion des erreurs.

Le langage C++ étant en plein changement, de nouvelles opportunités s'ouvriront
certainement pour pousser plus loin l'étude de la métaprogrammation statique.
De plus, avec la présence grandissante du paradigme fonctionnel dans les
langages populaires, il y a fort à parier que de nouvelles notions inspirées
de la théorie des catégories feront leur apparition en C++, ouvrant au passage
un monde de possibilités pour les designers de bibliothèques génériques.
