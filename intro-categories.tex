\section{La théorie des catégories}

\subsection{Définition formelle}
    \newcommand{\C}{\mathcal{C}}
    \newcommand{\dom}{\mathrm{dom}}
    \newcommand{\range}{\mathrm{range}}
    \newcommand{\ob}[1]{\mathrm{ob}(#1)}

Une catégorie $\C$ est composée de trois choses:
\begin{enumerate}
    \item Une collection d'objets, habituellement notée $\ob{\C}$.
    \item Une collection de flèches (aussi appelées morphismes) entre ces
          objets, habituellement notée $\hom(\C)$.
    \item Une opération binaire, habituellement notée $\circ$, permettant de
          composer n'importe quelle paire de flèches dont les sources et
          destinations sont compatibles pour en obtenir une troisième.
\end{enumerate}

Pour que $\C$ soit une catégorie, ces ``choses'' doivent aussi respecter
certaines propriétés, qui seront expliquées un peu plus bas. Avant de
continuer, il est important de préciser quelques détails et d'introduire
un peu de notation qui rendra notre tâche plus facile pour la suite. D'abord,
pour deux objets $X, Y \in \ob{\C}$, on note la collection des flèches allant
de $X$ vers $Y$ par $\hom(X, Y)$, ou encore $\hom_\C(X, Y)$ lorsque la catégorie
$\C$ n'est pas évidente à partir du contexte. On utilise aussi la notation
$f : X \to Y$ pour dire que $f$ est une flèche allant de $X$ vers $Y$,
c'est-à-dire que $f \in \hom(X, Y)$. On dit alors que $f$ est de source
$X$ et de destination $Y$, noté $\dom(f)$ et $\range(f)$ respectivement.

Ensuite, il est important de bien comprendre qu'on ne parle pas en réalité
d'une seule opération binaire, mais bien d'une opération binaire pour chaque
triplet d'objets $X, Y, Z \in \ob{\C}$. En effet, on souhaite définir notre
opération binaire de manière à ce qu'elle puisse composer n'importe quelles
deux flèches dont les sources et destinations sont compatibles, c'est-à-dire
que pour des flèches $f : Y \to Z$ et $g : X \to Y$, on puisse écrire
$f \circ g$. La définition de $\circ$ doit donc être de la forme
\begin{align*}
    \circ : \hom(Y, Z) \times \hom(X, Y) &\to \hom(X, Z) \\
             f, g &\mapsto f \circ g
\end{align*}

Il est donc nécessaire de parler d'une telle opération $\circ$ pour chaque
paire de $\hom$-classe $\left(\hom(Y, Z), \hom(X, Y)\right)$, ou, de manière
équivalente, pour chaque triplet d'objets $\left(X, Y, Z\right)$. Pour justifier
rigoureusement notre abus de langage, appelons $\circ_{\left(X,Y,Z\right)}$
l'opération binaire associée au triplet d'objets $\left(X,Y,Z\right)$.
Il suffit maintenant de définir la composition comme
\begin{align*}
    \circ : \bigcup \left\{ \mathrm{dom}(\circ_{\left(X,Y,Z\right)})
                            \suchthat X, Y, Z \in \ob{\C} \right\} &\to \hom(\C) \\
           f, g &\mapsto f \circ_{\left(\dom(g), \range(g), \range(f)\right)} g
\end{align*}
, ce qui nous permet de composer n'importe quelles deux flèches dont les sources
et destinations sont compatibles sans s'enfarger dans les fleurs du tapis. Nous
sommes maintenant prêts à passer aux propriétés qui doivent être satisfaitent
pour qu'on ait bien une catégorie. D'abord, pour tout objet $X \in ob(\C)$, il
doit exister une flèche de $X$ vers lui-même, qu'on appelle généralement
identité (sur $X$):
\[
    \mathrm{id}_X : X \to X
\]

Ensuite, la composition $\circ$ définie plus haut doit être associative,
c'est-à-dire que pour toutes flèches $f : C \to D$, $g : B \to C$ et
$h : A \to B$, on doit avoir
\[
    (f \circ g) \circ h = f \circ (g \circ h)
\]

Finalement, on doit avoir que les identités sont des éléments neutres de la
composition, c'est-à-dire que pour toute flèche $f : A \to B$,
\[
    f = \mathrm{id}_B \circ f = f \circ \mathrm{id}_A
\]

Il est intéressant d'observer que ces deux dernières propriétés sont
semblables à demander que $\left(\hom(\C), \circ\right)$ soit un Monoïde.
Ce n'est évidemment pas le cas puisqu'on a plusieurs identités et parce
que $\circ$ n'est pas définie sur la totalité de $\hom(\C) \times \hom(\C)$,
mais l'intuition reste utile.



\subsection{Exemples de catégories}
\subsection{La catégorie Hask}


\subsection{La catégorie Hana}
La catégorie Hana est définie de manière similaire à Hask, mais les types
sont remplacés par la notion plus générale de \textit{tag}. En particulier,
les objets de Hana sont les tags:
\[
    Ob(Hana) := \{ T \suchthat \text{T est un \textit{tag}} \}
\]

Les morphismes de Hana sont les fonctions génériques qui travaillent sur des
objets ayant un certain tag, et ce peu importe le type réel de ces objets.
Plus précisément, soit $X, Y \in Ob(Hana)$, c'est-à-dire que $X$ et $Y$
sont deux tags. Un morphisme $f : X \to Y$ est un objet C++, disons {\tt f},
avec un {\tt operator()} tel que $\forall x \in X$,
\begin{enumerate}
    \item l'expression {\tt f(x)} est bien formée, c'est-à-dire qu'elle compile
    \item ${\tt f(x)} \in Y$, c'est-à-dire que le tag de l'expression {\tt f(x)} est $Y$
    \item l'expression {\tt f(x)} n'a pas d'effets de bord
\end{enumerate}

La propriété (3) est nécessaire pour s'assurer que les fonctions qu'on
considère sont des fonctions au sens mathématique, c'est-à-dire que
\[
    x = y \implies f(x) = f(y)
\]

Sans se restreindre explicitement à cette classe de fonctions, on perdrait la
capacité de raisonner mathématiquement à propos des fonctions de Hana puisque
le langage C++ n'est pas pur, contrairement au Haskell.

Finalement, la loi de composition sur Hana est, sans grande surprise,
l'extension de la composition de fonctions usuelle aux fonctions templates
qui constituent les morphismes de Hana, $Hom(Hana)$. Rigoureusement, soit
$X, Y, Z \in Ob(Hana)$, c'est-à-dire que $X$, $Y$ et $Z$ sont des tags.
On peut définir la composition par
\begin{minted}{c++}
    template <typename X, typename Y, typename Z>
    auto compose = [](auto f, auto g) {
        return [=](auto x) {
            static_assert(std::is_same<datatype_t<decltype(x)>, X>{}, "");
            static_assert(std::is_same<datatype_t<decltype(g(x))>, Y>{}, "");
            static_assert(std::is_same<datatype_t<decltype(f(g(x)))>, Z>{}, "");
            return f(g(x));
        };
    };
\end{minted}

Dans la réalité, il est trop répétitif de préciser les tags $X$, $Y$ et $Z$
et on préfère la définition suivante pour {\tt compose}:
\begin{minted}{c++}
    auto compose = [](auto f, auto g) {
        return [=](auto x) {
            return f(g(x));
        };
    };
\end{minted}

Il nous reste à démontrer que Hana est bien une catégorie. Pour ce faire, il
suffit de vérifier qu'il existe un morphisme identité pour chaque objet de
la catégorie et que la composition est bien associative.

\begin{proof}

\end{proof}
