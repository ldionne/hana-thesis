\section{Les monades}

\todo{Introduction avec un peu d'intuition; on s'en va tranquillement vers
la définition formelle.}

\begin{définition}[Monade]
    Soit $\C$ une catégorie et $I_\C : \C \to \C$ le foncteur identité sur
    $\C$. Une monade est un endofoncteur $F : \C \to \C$ accompagné de deux
    transformation naturelles $\eta : I_\C \to F$ et $\mu : F \circ F \to F$
    telles que pour tout objet $X \in \ob(\C)$ et toute flèche
    $f : X \to Y \in \hom(\C)$,
    \begin{enumerate}
        \item $\mu_X \circ F(\mu_X) = \mu_X \circ \mu_{F(X)}$
        \item $\mu_X \circ F(\eta_X) = \mu_X \circ \eta_{F(X)} = id_{F(X)}$
        \item $\eta_Y \circ f = F(f) \circ \eta_X$
        \item $\mu_Y \circ F(F(f)) = F(f) \circ \mu_X$
    \end{enumerate}
\end{définition}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Les monades dans Hana}
Pour déchiffrer cette définition un peu opaque, regardons maintenant comment
une monade est représentée dans Hana. Premièrement, on donne un nom plus
descriptif aux transformations naturelles $\eta$ et $\mu$. Puisque $\eta$
associe à tout objet $X \in \ob(\C)$ une flèche $\eta_X : I_\C(X) = X \to F(X)$,
on l'appellera \cc{lift}. Plus précisément, étant donné un type généralisé
paramétré \cc{F} et un type généralisé \cc{X}, $\cc{lift<X>} : \cc{X} \to \cc{F(X)}$
prend un objet de \cc{X} et ``l'injecte'' ou le ``monte'' dans le foncteur \cc{F}.

Ensuite, puisque $\mu$ associe à tout objet $X \in \ob(\C)$ une flèche
$\mu_X : F(F(X)) \to F(X)$, on l'appellera \cc{flatten}. Ici, l'intuition
est que $\cc{flatten<X>} : \cc{F(F(X))} \to \cc{F(X)}$ prend un objet
enveloppé dans deux niveaux de fonctorialité et élimine, ou écrase, un niveau
de fonctorialité. Pour alléger la notation, on notera parfois simplement
\cc{flatten} et \cc{lift} au lieu de \cc{flatten<...>} et \cc{lift<...>}.
En reformulant la définition d'une monade de cette manière, on obtient que
les deux transformations naturelles doivent respecter les équations suivantes.
D'abord, on doit avoir que
\begin{cpp}
    compose(flatten<X>, transform(-, flatten<X>))
        == compose(flatten<X>, flatten<F(X)>)
\end{cpp}

ce qui est équivalent à dire que pour tout objet $\cc{xs} \in \cc{F(F(F(X)))}$,
\begin{cpp}
    flatten(transform(xs, flatten)) == flatten(flatten(xs))
\end{cpp}

Considérant \cc{xs} comme une strucutre à ``3 niveaux'', cette loi dit donc
qu'écraser les niveaux intérieurs puis ensuite les niveaux extérieurs est
équivalent à écraser les niveaux extérieurs puis ensuite les niveaux
intérieurs. Quant à la deuxième loi, elle peut s'écrire comme
\begin{cpp}
    compose(flatten<X>, transform(-, lift<X>))
        == compose(flatten<X>, lift<F(X)>)
        == id
\end{cpp}

ce qui est équivalent à dire que pour tout objet $\cc{xs} \in \cc{F(X)}$,
\begin{cpp}
    flatten(transform(xs, lift)) == flatten(lift(xs)) == xs
\end{cpp}

D'abord, à droite on a \cc{flatten(lift(xs)) == xs}, ce qui veut simplement
dire que monter une valeur dans un foncteur puis écraser ce niveau de
fonctorialité devrait être équivalent à ne rien faire du tout. À gauche, on
a que \cc{flatten(transform(xs, lift)) == xs}, ce qui veut dire que monter
les valeurs dans un foncteur puis ensuite écraser ce nouveau niveau de
fonctorialité devrait être équivalent à ne rien faire. Cette loi permet
de s'assurer que \cc{flatten} et \cc{lift} ne cachent pas d'effets arbitraires.
Pour la suite, supposons que \cc{f} est une fonction $\cc{X} \to \cc{Y}$. La
troisième loi peut s'écrire comme
\begin{cpp}
    compose(lift<Y>, f) == compose(transform(-, f), lift<X>)
\end{cpp}

De manière équivalente, on peut dire que pour tout objet $\cc{x} \in \cc{X}$,
\begin{cpp}
    lift(f(x)) == transform(lift(x), f)
\end{cpp}

Ceci représente le fait qu'appliquer une fonction à une valeur simple montée
avec \cc{lift} à l'intérieur du foncteur est la même chose que d'effectuer
la transformation à l'extérieur du foncteur, puis de monter le résultat dans
le foncteur. Finalement, étant donné un objet $\cc{xs} \in \cc{F(F(X))}$, on
peut écrire la quatrième loi comme
\begin{cpp}
    flatten(transform(xs, transform(-, f))) == transform(flatten(xs), f)
\end{cpp}

Il est plus difficile de développer une intuition pour cette loi. Voyons
maintenant des exemples de Monades qui sont utilisées dans Hana.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{La monade Maybe}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{La monade Tuple}
