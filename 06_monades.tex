\section{Les monades}

\todo{Introduction avec un peu d'intuition; on s'en va tranquillement vers
la définition formelle.}

\begin{définition}[Monade]
    Soit $\C$ une catégorie et $I_\C : \C \to \C$ le foncteur identité sur
    $\C$. Une monade est un endofoncteur $F : \C \to \C$ accompagné de deux
    transformation naturelles $\eta : I_\C \to F$ et $\mu : F \circ F \to F$
    telles que pour tout objet $X \in \ob(\C)$ et toute flèche
    $f : X \to Y \in \hom(\C)$,
    \begin{enumerate}
        \item $\mu_X \circ F(\mu_X) = \mu_X \circ \mu_{F(X)}$
        \item $\mu_X \circ F(\eta_X) = \mu_X \circ \eta_{F(X)} = id_{F(X)}$
        \item $\eta_Y \circ f = F(f) \circ \eta_X$
        \item $\mu_Y \circ F(F(f)) = F(f) \circ \mu_X$
    \end{enumerate}
\end{définition}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Les monades dans Hana}
Pour déchiffrer cette définition un peu opaque, regardons maintenant comment
une monade est représentée dans Hana. Premièrement, on donne un nom plus
descriptif aux transformations naturelles $\eta$ et $\mu$. Puisque $\eta$
associe à tout objet $X \in \ob(\C)$ une flèche $\eta_X : I_\C(X) = X \to F(X)$,
on l'appellera \cc{lift}. Plus précisément, étant donné un type généralisé
paramétré \cc{F} et un type généralisé \cc{X}, $\cc{lift<X>} : \cc{X} \to \cc{F(X)}$
prend un objet de \cc{X} et ``l'injecte'' ou le ``monte'' dans le foncteur \cc{F}.

Ensuite, puisque $\mu$ associe à tout objet $X \in \ob(\C)$ une flèche
$\mu_X : F(F(X)) \to F(X)$, on l'appellera \cc{flatten}. Ici, l'intuition
est que $\cc{flatten<X>} : \cc{F(F(X))} \to \cc{F(X)}$ prend un objet
enveloppé dans deux niveaux de fonctorialité et élimine, ou écrase, un niveau
de fonctorialité. Pour alléger la notation, on notera parfois simplement
\cc{flatten} et \cc{lift} au lieu de \cc{flatten<...>} et \cc{lift<...>}.
En reformulant la définition d'une monade de cette manière, on obtient que
les deux transformations naturelles doivent respecter les équations suivantes.
D'abord, on doit avoir que
\begin{cpp}
    compose(flatten<X>, transform(-, flatten<X>))
        == compose(flatten<X>, flatten<F(X)>)
\end{cpp}

ce qui est équivalent à dire que pour tout objet $\cc{xs} \in \cc{F(F(F(X)))}$,
\begin{cpp}
    flatten(transform(xs, flatten)) == flatten(flatten(xs))
\end{cpp}

Considérant \cc{xs} comme une strucutre à ``3 niveaux'', cette loi dit donc
qu'écraser les niveaux intérieurs puis ensuite les niveaux extérieurs est
équivalent à écraser les niveaux extérieurs puis ensuite les niveaux
intérieurs. Quant à la deuxième loi, elle peut s'écrire comme
\begin{cpp}
    compose(flatten<X>, transform(-, lift<X>))
        == compose(flatten<X>, lift<F(X)>)
        == id
\end{cpp}

ce qui est équivalent à dire que pour tout objet $\cc{xs} \in \cc{F(X)}$,
\begin{cpp}
    flatten(transform(xs, lift)) == flatten(lift(xs)) == xs
\end{cpp}

D'abord, à droite on a \cc{flatten(lift(xs)) == xs}, ce qui veut simplement
dire que monter une valeur dans un foncteur puis écraser ce niveau de
fonctorialité devrait être équivalent à ne rien faire du tout. À gauche, on
a que \cc{flatten(transform(xs, lift)) == xs}, ce qui veut dire que monter
les valeurs dans un foncteur puis ensuite écraser ce nouveau niveau de
fonctorialité devrait être équivalent à ne rien faire. Cette loi permet
de s'assurer que \cc{flatten} et \cc{lift} ne cachent pas d'effets arbitraires.
Pour la suite, supposons que \cc{f} est une fonction $\cc{X} \to \cc{Y}$. La
troisième loi peut s'écrire comme
\begin{cpp}
    compose(lift<Y>, f) == compose(transform(-, f), lift<X>)
\end{cpp}

De manière équivalente, on peut dire que pour tout objet $\cc{x} \in \cc{X}$,
\begin{cpp}
    lift(f(x)) == transform(lift(x), f)
\end{cpp}

Ceci représente le fait qu'appliquer une fonction à une valeur simple montée
avec \cc{lift} à l'intérieur du foncteur est la même chose que d'effectuer
la transformation à l'extérieur du foncteur, puis de monter le résultat dans
le foncteur. Finalement, étant donné un objet $\cc{xs} \in \cc{F(F(X))}$, on
peut écrire la quatrième loi comme
\begin{cpp}
    flatten(transform(xs, transform(-, f))) == transform(flatten(xs), f)
\end{cpp}

Il est plus difficile de développer une intuition pour cette loi. Voyons
maintenant des exemples de Monades qui sont utilisées dans Hana.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{La monade Maybe}
Nous avons vu précédemment que \cc{Maybe} était un foncteur. En fait,
\cc{Maybe} est plus qu'un foncteur; c'est aussi une monade. D'abord,
l'opération \cc{lift} devrait avoir une signature $\cc{X} \to \cc{Maybe(X)}$.
La définition la plus naturelle pour une fonction ayant cette signature est
$\cc{lift} = \cc{just}$.

Ainsi, \cc{lift} prend une valeur normale et la ``monte'' dans une valeur
optionnelle. Ensuite, la fonction \cc{flatten} devrait avoir une signature
$\cc{Maybe(Maybe(X))} \to \cc{Maybe(X)}$. Encore une fois, la définition la
plus naturelle est la bonne:
\begin{align*}
    \cc{flatten} : \cc{Maybe(Maybe(X))} &\to \cc{Maybe(X)} \\
    \cc{just(just(x))} &\mapsto \cc{just(x)} \\
    \cc{just(nothing)} &\mapsto \cc{nothing} \\
    \cc{nothing} &\mapsto \cc{nothing}
\end{align*}

Montrons maintenant qu'il s'agit bien d'une monade. Pour montrer que la
première loi tient, considérons $\cc{mmm} \in \cc{Maybe(Maybe(Maybe(X)))}$.
Il y a quatre cas possibles.
\begin{enumerate}
    \item Si $\cc{mmm} = \cc{nothing}$, alors
    \begin{cpp}
        flatten(transform(nothing, flatten))
            == flatten(nothing)
            == nothing
            == flatten(flatten(nothing))
    \end{cpp}

    \item Si $\cc{mmm} = \cc{just(nothing)}$, alors
    \begin{cpp}
        flatten(transform(just(nothing), flatten))
            == flatten(just(flatten(nothing)))
            == flatten(just(nothing))
            == nothing
            == flatten(flatten(just(nothing)))
    \end{cpp}

    \item Si $\cc{mmm} = \cc{just(just(nothing))}$, alors
    \begin{cpp}
        flatten(transform(just(just(nothing)), flatten))
            == flatten(just(flatten(just(nothing))))
            == flatten(just(nothing))
            == nothing
            == flatten(flatten(just(just(nothing))))
    \end{cpp}

    \item Si au contraire on a $\cc{mmm} = \cc{just(just(just(x)))}$, alors
    \begin{cpp}
        flatten(transform(just(just(just(x))), flatten))
            == flatten(just(flatten(just(just(x)))))
            == flatten(just(just(x)))
            == flatten(flatten(just(just(just(x)))))
    \end{cpp}
\end{enumerate}

Ceci montre que la première loi est bien respectée. Pour la deuxième loi,
considérons maintenant $\cc{m} \in \cc{Maybe(X)}$. Il y a deux cas possibles.
\begin{enumerate}
    \item Si $\cc{m} = \cc{nothing}$, alors
    \begin{cpp}
        flatten(transform(nothing, lift)) == flatten(nothing)
                                          == nothing
                                          == flatten(just(nothing))
                                          == flatten(lift(nothing))
    \end{cpp}

    \item Si $\cc{m} = \cc{just(x)}$, alors
    \begin{cpp}
        flatten(transform(just(x), lift)) == flatten(just(lift(x)))
                                          == flatten(just(just(x)))
                                          == flatten(lift(just(x)))
                                          == just(x)
    \end{cpp}
\end{enumerate}

La troisième loi est facile à montrer. Soit $\cc{x} \in \cc{X}$ et
$\cc{f} : \cc{X} \to \cc{Y}$. Alors
\begin{cpp}
    lift(f(x)) == just(f(x))
               == transform(just(x), f)
               == transform(lift(x), f)
\end{cpp}

Finalement, pour un $\cc{mm} \in \cc{F(F(X))}$ la quatrième loi nous donne
\begin{enumerate}
    \item Si $\cc{mm} = \cc{nothing}$, alors
    \begin{cpp}
        flatten(transform(nothing, transform(-, f)))
            == flatten(nothing)
            == nothing
            == transform(nothing, f)
            == transform(flatten(nothing), f)
    \end{cpp}

    \item Si $\cc{mm} = \cc{just(nothing)}$, alors
    \begin{cpp}
        flatten(transform(just(nothing), transform(-, f)))
            == flatten(just(transform(nothing, f)))
            == flatten(just(nothing))
            == nothing
            == transform(nothing, f)
            == transform(flatten(just(nothing)), f)
    \end{cpp}

    \item Si $\cc{mm} = \cc{just(just(x))}$, alors
    \begin{cpp}
        flatten(transform(just(just(x)), transform(-, f)))
            == flatten(just(transform(just(x), f)))
            == flatten(just(just(f(x))))
            == just(f(x))
            == transform(just(x), f)
            == transform(flatten(just(just(x))), f)
    \end{cpp}
\end{enumerate}

Ceci montre que \cc{Maybe} est bien une monade. Mais à quoi ceci peut bien
servir?

\todo{Montrer l'utilité de composer des fonctions monadiques.}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{La monade Tuple}
Un autre foncteur que nous avons vu dans une section précédente est \cc{Tuple}.
Tout comme \cc{Maybe}, il s'agit non seulement d'un foncteur mais aussi d'une
monade. Afin d'alléger la notation, on dénotera par \cc{[x1, ..., xn]}
l'expression \cc{make_tuple(x1, ..., xn)}. Premièrement, on peut définir
\cc{lift} comme
\begin{align*}
    \cc{lift} : \cc{X} &\to \cc{Tuple(X)}           \\
                \cc{x} &\mapsto \cc{[x]}  \\
\end{align*}

\cc{lift} prend simplement un élément et le met dans un tuple singleton.
Ensuite, on peut définir \cc{flatten} comme
\begin{align*}
    \cc{flatten} : \cc{Tuple(Tuple(X))} &\to \cc{Tuple(X)} \\
                   \cc{[[x1, ..., xn], ..., [y1, ..., ym]]} &\mapsto \cc{[x1, ..., xn, y1, ..., ym]}
\end{align*}

Montrons maintenant que \cc{Tuple} est bien une monade. D'abord, pour montrer
la première loi, considérons $\cc{xss} \in \cc{Tuple(Tuple(Tuple(X)))}$. Pour
simplifier la notation, on écrira \cc{xss = [[[x...]...]...]}, et \cc{x... ...}
représentera la concaténation des listes contenues dans \cc{[[x...]...]}.
On a alors
\begin{cpp}
    flatten(transform([[[x...]...]...], flatten))
        == flatten([flatten([[x...]...]])...])
        == flatten([[x... ...]...])
        == flatten(flatten([[[x...]...]...]))
\end{cpp}

Ensuite, pour la deuxième loi, on a bien que pour tout
$\cc{xs = [x...]} \in \cc{Tuple(X)}$,
\begin{cpp}
    flatten(transform([x...], lift)) == flatten([lift(x)...])
                                     == flatten([[x]...])
                                     == [x...]
                                     == flatten([[x...]])
                                     == flatten(lift([x...]))
\end{cpp}

La troisième loi est facile à voir. Étant donné un objet $\cc{x} \in \cc{X}$
et une fonction $\cc{f} : \cc{X} \to \cc{Y}$, on a bien
\begin{cpp}
    lift(f(x)) == [f(x)]
               == transform([x], f)
               == transform(lift(x), f)
\end{cpp}

Finalement, la quatrième et dernière loi est elle aussi respectée, puisque
pour un objet $\cc{xs = [[x...]...]} \in \cc{Tuple(Tuple(X))}$, on a
\begin{cpp}
    flatten(transform([[x...]...], transform(-, f)))
                        == flatten([transform([x...], f)...])
                        == flatten([[f(x)...]...])
                        == [f(x)... ...]
                        == transform([x... ...], f)
                        == transform(flatten([[x...]...]), f)
\end{cpp}
