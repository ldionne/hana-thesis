\section{Les monades}

\todo{Introduction avec un peu d'intuition; on s'en va tranquillement vers
la définition formelle.}

\begin{définition}[Monade]
    Soit $\C$ une catégorie et $I_\C : \C \to \C$ le foncteur identité sur
    $\C$. Une monade est un endofoncteur $F : \C \to \C$ accompagné de deux
    transformation naturelles $\eta : I_\C \to F$ et $\mu : F \circ F \to F$
    telles que pour tout objet $X \in \ob(\C)$ et toute flèche
    $f : X \to Y \in \hom(\C)$,
    \begin{enumerate}
        \item $\mu_X \circ F(\mu_X) = \mu_X \circ \mu_{F(X)}$
        \item $\mu_X \circ F(\eta_X) = \mu_X \circ \eta_{F(X)} = id_{F(X)}$
        \item $\eta_Y \circ f = F(f) \circ \eta_X$
        \item $\mu_Y \circ F(F(f)) = F(f) \circ \mu_X$
    \end{enumerate}
\end{définition}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Les monades dans Hana}
Pour déchiffrer cette définition un peu opaque, regardons maintenant comment
une monade est représentée dans Hana. Premièrement, on donne un nom plus
descriptif aux transformations naturelles $\eta$ et $\mu$. Puisque $\eta$
associe à tout objet $X \in \ob(\C)$ une flèche $\eta_X : I_\C(X) = X \to F(X)$,
on l'appellera \cc{lift}. Plus précisément, étant donné un type généralisé
paramétré \cc{F} et un type généralisé \cc{X}, $\cc{lift<X>} : \cc{X} \to \cc{F(X)}$
prend un objet de \cc{X} et ``l'injecte'' ou le ``monte'' dans le foncteur \cc{F}.

Ensuite, puisque $\mu$ associe à tout objet $X \in \ob(\C)$ une flèche
$\mu_X : F(F(X)) \to F(X)$, on l'appellera \cc{flatten}. Ici, l'intuition
est que $\cc{flatten<X>} : \cc{F(F(X))} \to \cc{F(X)}$ prend un objet
enveloppé dans deux niveaux de fonctorialité et élimine, ou écrase, un niveau
de fonctorialité. Pour alléger la notation, on notera parfois simplement
\cc{flatten} et \cc{lift} au lieu de \cc{flatten<...>} et \cc{lift<...>}.
En reformulant la définition d'une monade de cette manière, on obtient que
les deux transformations naturelles doivent respecter les équations suivantes.
D'abord, on doit avoir que
\begin{cpp}
    compose(flatten<X>, transform(-, flatten<X>))
        == compose(flatten<X>, flatten<F(X)>)
\end{cpp}

ce qui est équivalent à dire que pour tout objet $\cc{xs} \in \cc{F(F(F(X)))}$,
\begin{cpp}
    flatten(transform(xs, flatten)) == flatten(flatten(xs))
\end{cpp}

Considérant \cc{xs} comme une strucutre à ``3 niveaux'', cette loi dit donc
qu'écraser les niveaux intérieurs puis ensuite les niveaux extérieurs est
équivalent à écraser les niveaux extérieurs puis ensuite les niveaux
intérieurs. Quant à la deuxième loi, elle peut s'écrire comme
\begin{cpp}
    compose(flatten<X>, transform(-, lift<X>))
        == compose(flatten<X>, lift<F(X)>)
        == id
\end{cpp}

ce qui est équivalent à dire que pour tout objet $\cc{xs} \in \cc{F(X)}$,
\begin{cpp}
    flatten(transform(xs, lift)) == flatten(lift(xs)) == xs
\end{cpp}

D'abord, à droite on a \cc{flatten(lift(xs)) == xs}, ce qui veut simplement
dire que monter une valeur dans un foncteur puis écraser ce niveau de
fonctorialité devrait être équivalent à ne rien faire du tout. À gauche, on
a que \cc{flatten(transform(xs, lift)) == xs}, ce qui veut dire que monter
les valeurs dans un foncteur puis ensuite écraser ce nouveau niveau de
fonctorialité devrait être équivalent à ne rien faire. Cette loi permet
de s'assurer que \cc{flatten} et \cc{lift} ne cachent pas d'effets arbitraires.
Pour la suite, supposons que \cc{f} est une fonction $\cc{X} \to \cc{Y}$. La
troisième loi peut s'écrire comme
\begin{cpp}
    compose(lift<Y>, f) == compose(transform(-, f), lift<X>)
\end{cpp}

De manière équivalente, on peut dire que pour tout objet $\cc{x} \in \cc{X}$,
\begin{cpp}
    lift(f(x)) == transform(lift(x), f)
\end{cpp}

Ceci représente le fait qu'appliquer une fonction à une valeur simple montée
avec \cc{lift} à l'intérieur du foncteur est la même chose que d'effectuer
la transformation à l'extérieur du foncteur, puis de monter le résultat dans
le foncteur. Finalement, étant donné un objet $\cc{xs} \in \cc{F(F(X))}$, on
peut écrire la quatrième loi comme
\begin{cpp}
    flatten(transform(xs, transform(-, f))) == transform(flatten(xs), f)
\end{cpp}

Il est plus difficile de développer une intuition pour cette loi. Voyons
maintenant des exemples de Monades qui sont utilisées dans Hana.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{La monade Maybe}
Nous avons vu précédemment que \cc{Maybe} était un foncteur. En fait,
\cc{Maybe} est plus qu'un foncteur; c'est aussi une monade. D'abord,
l'opération \cc{lift} devrait avoir une signature $\cc{X} \to \cc{Maybe(X)}$.
La définition la plus naturelle pour une fonction ayant cette signature est
$\cc{lift} = \cc{just}$.

Ainsi, \cc{lift} prend une valeur normale et la ``monte'' dans une valeur
optionnelle. Ensuite, la fonction \cc{flatten} devrait avoir une signature
$\cc{Maybe(Maybe(X))} \to \cc{Maybe(X)}$. Encore une fois, la définition la
plus naturelle est la bonne:
\begin{align*}
    \cc{flatten} : \cc{Maybe(Maybe(X))} &\to \cc{Maybe(X)} \\
    \cc{just(just(x))} &\mapsto \cc{just(x)} \\
    \cc{just(nothing)} &\mapsto \cc{nothing} \\
    \cc{nothing} &\mapsto \cc{nothing}
\end{align*}

Montrons maintenant qu'il s'agit bien d'une monade. Pour montrer que la
première loi tient, considérons $\cc{mmm} \in \cc{Maybe(Maybe(Maybe(X)))}$.
Il y a quatre cas possibles.
\begin{enumerate}
    \item Si $\cc{mmm} = \cc{nothing}$, alors
    \begin{cpp}
        flatten(transform(nothing, flatten))
            == flatten(nothing)
            == nothing
            == flatten(flatten(nothing))
    \end{cpp}

    \item Si $\cc{mmm} = \cc{just(nothing)}$, alors
    \begin{cpp}
        flatten(transform(just(nothing), flatten))
            == flatten(just(flatten(nothing)))
            == flatten(just(nothing))
            == nothing
            == flatten(flatten(just(nothing)))
    \end{cpp}

    \item Si $\cc{mmm} = \cc{just(just(nothing))}$, alors
    \begin{cpp}
        flatten(transform(just(just(nothing)), flatten))
            == flatten(just(flatten(just(nothing))))
            == flatten(just(nothing))
            == nothing
            == flatten(flatten(just(just(nothing))))
    \end{cpp}

    \item Si au contraire on a $\cc{mmm} = \cc{just(just(just(x)))}$, alors
    \begin{cpp}
        flatten(transform(just(just(just(x))), flatten))
            == flatten(just(flatten(just(just(x)))))
            == flatten(just(just(x)))
            == flatten(flatten(just(just(just(x)))))
    \end{cpp}
\end{enumerate}

Ceci montre que la première loi est bien respectée. Pour la deuxième loi,
considérons maintenant $\cc{m} \in \cc{Maybe(X)}$. Il y a deux cas possibles.
\begin{enumerate}
    \item Si $\cc{m} = \cc{nothing}$, alors
    \begin{cpp}
        flatten(transform(nothing, lift)) == flatten(nothing)
                                          == nothing
                                          == flatten(just(nothing))
                                          == flatten(lift(nothing))
    \end{cpp}

    \item Si $\cc{m} = \cc{just(x)}$, alors
    \begin{cpp}
        flatten(transform(just(x), lift)) == flatten(just(lift(x)))
                                          == flatten(just(just(x)))
                                          == flatten(lift(just(x)))
                                          == just(x)
    \end{cpp}
\end{enumerate}

La troisième loi est facile à montrer. Soit $\cc{x} \in \cc{X}$ et
$\cc{f} : \cc{X} \to \cc{Y}$. Alors
\begin{cpp}
    lift(f(x)) == just(f(x))
               == transform(just(x), f)
               == transform(lift(x), f)
\end{cpp}

Finalement, pour un $\cc{mm} \in \cc{F(F(X))}$ la quatrième loi nous donne
\begin{enumerate}
    \item Si $\cc{mm} = \cc{nothing}$, alors
    \begin{cpp}
        flatten(transform(nothing, transform(-, f)))
            == flatten(nothing)
            == nothing
            == transform(nothing, f)
            == transform(flatten(nothing), f)
    \end{cpp}

    \item Si $\cc{mm} = \cc{just(nothing)}$, alors
    \begin{cpp}
        flatten(transform(just(nothing), transform(-, f)))
            == flatten(just(transform(nothing, f)))
            == flatten(just(nothing))
            == nothing
            == transform(nothing, f)
            == transform(flatten(just(nothing)), f)
    \end{cpp}

    \item Si $\cc{mm} = \cc{just(just(x))}$, alors
    \begin{cpp}
        flatten(transform(just(just(x)), transform(-, f)))
            == flatten(just(transform(just(x), f)))
            == flatten(just(just(f(x))))
            == just(f(x))
            == transform(just(x), f)
            == transform(flatten(just(just(x))), f)
    \end{cpp}
\end{enumerate}

Ceci montre que \cc{Maybe} est bien une monade. Mais à quoi ceci peut bien
servir?

\todo{Montrer l'utilité de composer des fonctions monadiques.}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{La monade Tuple}
