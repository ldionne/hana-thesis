<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="author", content="Louis Dionne">
    <title>Théorie des catégories++</title>
    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/default.css" id="theme">
    <link rel="stylesheet" href="lib/css/highlight/zenburn.css">
    <link rel="stylesheet" href="css/styles.css">
</head>

<body>
    <div class="reveal">
        <div class="slides">
            <section data-markdown=""
                     data-separator="^====+$"
                     data-vertical="^----+$"
                     data-notes="^Note:">
            <script type="text/template">

## Théorie des catégories++

====================

## Plan de match
- Survol du système de typage du C++
- Introduction à la métaprogrammation en C++
- Introduction aux catégories
- __Fusion__!

==============================================================================

### Le système de typage du C++

<!-- On définit les commandes MathJax dans la 3eme slide pour éviter de
     les voir se loader lorsqu'on commence la présentation. -->

$\newcommand{\cc}[1]{{\tt #1}}$
$\newcommand{\sub}[1]{_{#1}}$
$\newcommand{\C}{\mathcal{C}}$
$\newcommand{\D}{\mathcal{D}}$
$\newcommand{\ob}{\mathrm{ob}}$
$\newcommand{\id}{\mathrm{id}}$
$\newcommand{\hom}{\mathrm{hom}}$

$\newcommand{\Set}{\mathrm{Set}}$
$\newcommand{\Grp}{\mathrm{Grp}}$
$\newcommand{\Top}{\mathrm{Top}}$
$\newcommand{\Cxx}{\mathrm{C++}}$
$\newcommand{\Hana}{\mathrm{Hana}}$

====================

### Qu'est-ce qu'un type?
En gros, c'est un ensemble de valeurs

$\cc{int} := \\{ -32 767, \dots, 32 767 \\}$
$\cc{string} := \\{\text{toutes les chaînes de caractères}\\}$

Note:
Ça permet au compilateur de connaître la représentation des objets
et de les stocker dans l'ordinateur.

----

### On doit spécifier le type des objets qu'on manipule

__Maths__
$$n := 33 \in {\cc{unsigned\ int}}$$
$$s := Bonjour \in \cc{string}$$

__C++__
```cpp
int n = 33;
string s = "Bonjour";
```

----

### On peut définir des fonctions

__Maths__
$$
    \begin{matrix}
        \cc{f} : \cc{int} \to \cc{int} \\\\
                       x  \mapsto x^2
    \end{matrix}
$$

__C++__
```cpp
auto f(int x) -> int {
    return x * x;
}
```

Note:
Cette fonction est en fait mal définie, parce que e.g.
$32767^2 \not\in \cc{int}$.

----

### En C++, on peut aussi définir nos propres types

```cpp
struct Personne {
    string nom;
    int age;
};

int main() {
    Personne john = {"John", 30};
}
```

====================

### Les templates

## Sauve qui peut! <!-- .element: class="fragment" -->

====================

### Sérieusement
#### Juste une famille de types indexés sur les types

__Maths__
$$
    \\{ \cc{X_T} \\}\sub{\cc{T} \in \cc{Type}}
$$

__C++__
```cpp
template <typename T>
struct X {
    // ...
};

X<int> i = {...};
X<string> s = {...};
```

----

#### Par exemple

__Maths__
$$
    \\{ \cc{list_T} \\}\sub{\cc{T} \in \cc{Type}}
$$

__C++__
```cpp
template <typename T>
struct list {
    // ...
};

list<int> ns = {0, 1, 2, 3, 4};
list<string> str = {"bonjour", "hello", "hola"};
```

====================

#### On a aussi des fonctions indexées sur les types

__Maths__
$$
    \\{ \cc{f_T} : \cc{A_T} \to \cc{B_T} \\}\sub{\cc{T} \in \cc{Type}}
$$

__C++__
```cpp
template <typename T>
auto f(A<T> x) -> B<T> {
    // ...
}

A<int> x = {...};
A<string> y = {...};

f(x); // appelle f : A<int> -> B<int>
f(y); // appelle f : A<string> -> B<string>
```

----

#### Par exemple

__Maths__
$$
    \cc{at_T} : \cc{int} \times \cc{list_T} \to \cc{T}
$$

__C++__
```cpp
template <typename T>
T at(int n, list<T> xs) {
    // ...
}

list<int> ns = {0, 1, 2, 3, 4};
int trois = at(3, ns);

list<string> str = {"bonjour", "hello", "hola"};
string hello = at(1, str);
```

==============================================================================

### Et la métaprogrammation dans tout ça?
#### Une famille indexée est une fonction sous le couvert... <!-- .element: class="fragment" -->

====================

### Les templates sont donc des fonctions sur les types

$$
    \begin{matrix}
        \\{ \cc{X_T} \\}\sub{\cc{T} \in \cc{Type}}  \\\\
                        \simeq                      \\\\
            \cc{X} : \cc{Type} \to \cc{Type}        \\\\
                       \cc{T} \to \cc{X_T}
    \end{matrix}
$$

----

### Observation analogue pour les fonctions

$$
    \begin{matrix}
        \\{ \cc{f_T} : \cc{A_T} \to \cc{B_T} \\}\sub{\cc{T} \in \cc{Type}}  \\\\
                            \simeq                                          \\\\
            \cc{f} : \cc{Type} \to \left(\cc{A_T} \to \cc{B_T}\right)       \\\\
                        \cc{T} \mapsto \cc{f_T}
    \end{matrix}
$$

----

### Formalisation rigoureuse: types dépendants
#### Pas le temps :-( <!-- .element: class="fragment" -->

====================

### C'est ça qu'on manipule en métaprogrammation

====================

### Un exemple s'il vous plaît?

<!-- TODO -->

====================

### Mais ça sert à quoi?

- Analyse dimensionnelle
- Introspection
- Optimisations de haut niveau
- Parallélisation automatique
- $\infty$ d'exemples...

==============================================================================

### La théorie des catégories

====================

Une catégorie $\C$ est

- une collection d'objets $\ob(\C)$
- une collection de morphismes $\hom(\C)$
- une loi de composition $\circ$
<br><br>
(avec certaines règles)

----

<!-- TODO: Qu'est-ce que les objets et les morphismes -->

----

<!-- TODO: Qu'est-ce que la loi de composition -->

====================

### Exemples

----

#### $\Set$

- $\ob(\Set) = \\{ \text{ensembles} \\}$
- $\hom(X, Y) = \\{ \text{fonctions } f : X \to Y \\}$
- $\circ = \text{composition usuelle}$

----

#### $\Grp$

- $\ob(\Grp) = \\{ \text{groupes} \\}$
- $\hom(X, Y) = \\{ \text{homomorphismes } f : X \to Y \\}$
- $\circ = \text{composition usuelle}$

----

#### $\Top$

- $\ob(\Top) = \\{ \text{espaces topologiques} \\}$
- $\hom(X, Y) = \\{ \text{applications continues } f : X \to Y \\}$
- $\circ = \text{composition usuelle}$

----

#### $\Cxx$

- $\ob(\Cxx) = \\{ \text{types } \cc{T} \\}$
- $\hom(\cc{X}, \cc{Y}) = \\{ \text{fonctions } \cc{f} : \cc{X} \to \cc{Y} \\}$
- $\circ = \text{composition usuelle}$

Note:
Il faut se limiter aux fonctions pures et qui terminent.
Il faut aussi oublier `void` & al, mais tout ça est justifiable.

====================

### Les foncteurs

<!-- TODO -->

==============================================================================

### Le plat de résistance

====================

### La catégorie $\Hana$
#### (Hana = nom de la bibliothèque)

<!-- TODO -->

- $\ob(\Hana) = $
- $\hom(\cc{X}, \cc{Y}) = $
- $\circ = \text{composition usuelle}$

====================

### Foncteurs

<!-- TODO -->

====================

### Applications

====================

### $\cc{Maybe}$

<!-- TODO -->

====================

### $\cc{Tuple}$

<!-- TODO -->

==============================================================================

## Merci

            </script>
            </section>
        </div>
    </div>


    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>
    <script>
        Reveal.initialize({
            slideNumber: true,
            history: true,
            transition: 'slide',
            transitionSpeed: 'fast',

            dependencies: [
                { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
                { src: 'plugin/math/math.js', async: true }
            ]
        });
    </script>
</body>

</html>
